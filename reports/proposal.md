# HackerChat
## Software Systems Project 1
### Ashley, Nathan, Sherrie
#### Feb 17th, 2019

## Project Goals
Our minimum viable product is to create a two-way chat application that operates from the command line. A stretch goal would be to make it multi-user and add functionality beyond text.

## Learning Goals
We want to increase our comfort level of developing in C and expanding our knowledge of C. By the end of the project, we should understand and be able to implement mechanics of creating client and server with socket programming in C. We should learn the data structure and applications of creating a network such as a TCP/IP client server model. If time allows, we would like to explore other ways networking such as UDP and threading.

## Resources
We first need to learn about basic concepts of server-client communications. We plan to start this by reading Chapter 11 of Head First C and Chapter 9 of Think OS. From there, we will continue seeking out resources as needed to develop our understanding. We have also found several chat-room repositories on GitHub that we can reference throughout the process. Additionally, we have found project ideas for expanding beyond a 2-person chat room that outline the difficulty level of different expansions.

## Plan/First Steps
We will first brush up on the topic using resources we are familiar with. Allen Downey recommended chapter 11 of Head First C as a place to start so we will begin there. The task will be “done” after all team members have read this.

Next, we will research basic theory of client/server interaction and look at example code of a 2-user chat room application to gain a better understanding of what we’re building and how it works. This will aid us in developing a big picture vision of our project. This task will also be done by all team members and will be considered done when all members can articulate the basics of how a simplistic client-server model would communicate.

Then, we will start building our own. All together, the team will sketch a model and members will each be assigned a part of the functionality to code. Their tasks will be done when their portion works with given parameters and yields the expected output/results.
